#include "EntangledPhotonPairSource.h"
#include "PhotonicQubit_m.h"
#include "modules/Backend/PhysicalServiceFacade.h"
#include "modules/QNIC/StationaryQubit/QubitId.h"

using quisp::messages::PhotonicQubit;
using quisp::modules::backend::PhysicalServiceFacade;
using quisp::modules::backend::QubitHandle;
using quisp::modules::qubit_id::QubitId;
using namespace omnetpp;

namespace {

QubitHandle makeHandle(const quisp::backends::IQubit* qubit) {
  if (qubit == nullptr) throw cRuntimeError("EntangledPhotonPairSource::makeHandle: null qubit");
  const auto* id = qubit->getId();
  if (id == nullptr) throw cRuntimeError("EntangledPhotonPairSource::makeHandle: qubit has no id");
  const auto* qid = dynamic_cast<const QubitId*>(id);
  if (qid == nullptr) throw cRuntimeError("EntangledPhotonPairSource::makeHandle: unsupported qubit id type");
  return QubitHandle{qid->node_addr, qid->qnic_index, qid->qnic_type, qid->qubit_addr};
}

}  // namespace

namespace quisp::modules {

Define_Module(EntangledPhotonPairSource);
EntangledPhotonPairSource::EntangledPhotonPairSource() : provider(utils::ComponentProvider{this}) {}

EntangledPhotonPairSource::~EntangledPhotonPairSource() {}

void EntangledPhotonPairSource::finish() {}

void EntangledPhotonPairSource::initialize() {
  emission_success_probability = par("emission_success_probability").doubleValue();
  emission_x_error_rate = par("emission_x_error_rate").doubleValue();
  emission_y_error_rate = par("emission_y_error_rate").doubleValue();
  emission_z_error_rate = par("emission_z_error_rate").doubleValue();
  emission_jittering_standard_deviation = par("emission_jittering_standard_deviation").doubleValue();

  backend = provider.getQuantumBackend();
}

/**
 * \brief handle PhotonicQubit generated by StationaryQubit itself
 *
 * \param msg is the PhotonicQubit message
 */
void EntangledPhotonPairSource::handleMessage(cMessage *msg) {
  if (!msg->isSelfMessage()) {
    throw cRuntimeError("EntangledPhotonPairSource::handleMessage: message from outside is not expected");
  }
  int port = 0;
  if (strcmp(msg->getName(), "RightPhoton")) port = 1;
  double rand = dblrand();
  if (rand < (1 - emission_success_probability)) {
    PhotonicQubit *pk = check_and_cast<PhotonicQubit *>(msg);
    pk->setLost(true);
    send(pk, "quantum_port$o", port);
  } else {
    send(msg, "quantum_port$o", port);
  }
}

void EntangledPhotonPairSource::emitPhotons() {
  Enter_Method("emitPhotons()");
  auto *left_photon = new PhotonicQubit("LeftPhoton");
  auto *right_photon = new PhotonicQubit("RightPhoton");
  auto *left_photon_ref = backend->getShortLiveQubit();
  auto *right_photon_ref = backend->getShortLiveQubit();
  auto source_handle = makeHandle(left_photon_ref);
  auto target_handle = makeHandle(right_photon_ref);
  PhysicalServiceFacade service{backend};
  auto hadamard = service.applyGate("H", {source_handle});
  if (!hadamard.success) {
    throw cRuntimeError("EntangledPhotonPairSource::emitPhotons: hadamard failed");
  }
  auto cnot = service.applyGate("CNOT", {source_handle, target_handle});
  if (!cnot.success) {
    throw cRuntimeError("EntangledPhotonPairSource::emitPhotons: cnot failed");
  }
  left_photon->setQubitRef(left_photon_ref);
  right_photon->setQubitRef(right_photon_ref);

  left_photon->setFirst(true);
  right_photon->setFirst(true);
  left_photon->setLast(true);
  right_photon->setLast(true);
  float jitter_timing = normal(0, emission_jittering_standard_deviation);
  float abso = fabs(jitter_timing);
  scheduleAt(simTime() + abso, left_photon);
  scheduleAt(simTime() + abso, right_photon);
}

}  // namespace quisp::modules
